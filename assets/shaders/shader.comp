#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform writeonly image2D output_image;

layout (std430, set = 1, binding = 0) readonly buffer config {
    mat4  camera_transform;
    float camera_fov;
    uint  objects_count;

} in_config;

#define OBJECT_TYPE_SPHERE 1u

struct Object {
    uint object_type;
    vec4 color;
    vec4 data1; // Position
    vec4 data2; // For spheres: radius in x component
};

layout (std430, set = 1, binding = 1) readonly buffer world_objects {
    Object objects[];
};

layout (push_constant) uniform constants {
    float time;

} in_runtime;

vec4 sky_color(vec3 direction) {
    float t = 0.5 * (direction.y + 1.0);
    return mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0, 0.0, 1.0, 1.0), t);
}

float hits_sphere(vec3 center, float radius, vec3 ray_origin, vec3 ray_direction) {
    vec3 oc = ray_origin - center;
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(oc, ray_direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return -1.0; // No intersection
    } else {
        return (-b - sqrt(discriminant)) / (2.0 * a);
    }
}

float hits_object(Object obj, vec3 ray_origin, vec3 ray_direction) {
    if (obj.object_type == OBJECT_TYPE_SPHERE) {
        vec3 center = obj.data1.xyz;
        float radius = obj.data2.x;
        return hits_sphere(center, radius, ray_origin, ray_direction);
    } else {
        return -1.0; // Unsupported object type
    }
}

struct hit_s {
    float t;
    vec3 point;
    vec3 normal;
    vec3 color;
};

bool hits_world(vec3 ray_origin, vec3 ray_direction, out hit_s hit) {
    float closest_t = 1e20;
    bool hit_anything = false;
    int closest_index = -1;

    for (int i = 0; i <int(in_config.objects_count); i++) {
        float t = hits_object(objects[i], ray_origin, ray_direction);
        if (t > 0.0 && t < closest_t) {
            closest_t = t;
            closest_index = i;
            hit_anything = true;
        }
    }

    if (hit_anything) {
        hit.t = closest_t;
        hit.point = ray_origin + closest_t * ray_direction;
        Object hit_object = objects[closest_index];
        hit.normal = normalize(hit.point - hit_object.data1.xyz);
        hit.color = hit_object.color.rgb;
    }

    return hit_anything;
}

vec4 trace(vec3 camera_position, vec3 ray_direction) {
    hit_s hit;
    if (hits_world(camera_position, ray_direction, hit)) {
        // Simple shading based on normal
        float lighting = max(dot(hit.normal, normalize(vec3(1.0, 1.0, 1.0))), 0.0);
        vec3 color = hit.color * lighting;
        return vec4(color, 1.0);
    }

    // If no hit, return sky color
    return sky_color(ray_direction);
}

void main() {
    ivec2 viewport = imageSize(output_image);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    if (pixel_coords.x >= viewport.x || pixel_coords.y >= viewport.y)
    {
        return;
    }

    vec2 uv = (vec2(pixel_coords) + 0.5) / vec2(viewport); // [0..1]
    vec2 ndc = uv * 2.0 - 1.0; // [-1..1]
    float aspect = float(viewport.x) / float(viewport.y);
    ndc.x *= aspect;

    float fov = in_config.camera_fov.x;
    float scale = tan(fov * 0.5);
    vec3 dir_cam = normalize(vec3(ndc * scale, -1.0));

    vec3 camera_forward = normalize(in_config.camera_transform[2].xyz);
    vec3 camera_right = normalize(in_config.camera_transform[0].xyz);
    vec3 camera_up = normalize(in_config.camera_transform[1].xyz);
    vec3 dir_world = normalize(
        dir_cam.x * camera_right +
        dir_cam.y * camera_up +
        dir_cam.z * camera_forward
    );
    vec3 camera_position = in_config.camera_transform[3].xyz;

    vec4 new_pixel = trace(camera_position, dir_world);

    imageStore(output_image, pixel_coords, new_pixel);
}
