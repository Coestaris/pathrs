#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D output_image;

// TODO: Compile-time configuration as VkSpecializationInfo
layout (std430, set = 1, binding = 0) readonly buffer config {
    mat4  camera_transform;
    float camera_fov;
    uint  objects_count;
    uint  samples_count;
    float jitter_strength;
    float temporal_accumulation;

} in_config;

#define OBJECT_TYPE_SPHERE 1u

struct Object {
    uint object_type;
    vec4 albedo;
    vec4 metallic_roughness;// metallic in x, roughness in y
    vec4 data1;// Position
    vec4 data2;// For spheres: radius in x component
};

layout (std430, set = 1, binding = 1) readonly buffer world_objects {
    Object objects[];
};

layout (push_constant) uniform constants {
    float time;
    uint invalidate;

} in_runtime;

// Returns a random float in [0,1)
float rand(inout uint seed) {
    seed = seed * 1664525u + 1013904223u;  // LCG
    return float(seed) * (1.0 / 4294967296.0); // / 2^32
}

vec3 rand_unit(inout uint seed) {
    return normalize(vec3(
        rand(seed) * 2.0 - 1.0,
        rand(seed) * 2.0 - 1.0,
        rand(seed) * 2.0 - 1.0
    ));
}

vec3 rand_hemisphere(vec3 normal, inout uint seed) {
    vec3 in_unit_sphere = rand_unit(seed);
    if (dot(in_unit_sphere, normal) > 0.0) {
        return in_unit_sphere;
    } else {
        return -in_unit_sphere;
    }
}

vec3 sky_color(vec3 direction) {
    float t = 0.5 * (direction.y + 1.0);
    return mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), t);
}

struct minmax_s {
    float min;
    float max;
};

float hits_sphere(vec3 center, float radius, vec3 ray_origin, vec3 ray_direction, minmax_s bounds) {
    vec3 oc = ray_origin - center;
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(oc, ray_direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    // No intersection
    if (discriminant < 0.0) {
        return -1.0;
    }

    // Find the nearest t that is in front of the ray
    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
    if (t1 > bounds.min && t1 < bounds.max) {
        return t1;
    }

    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);
    if (t2 > bounds.min && t2 < bounds.max) {
        return t2;
    }

    return -1.0;
}

struct hit_s {
    bool valid;
    float t;
    vec3 point;
    vec3 normal;
    bool front_face;

    // Material properties
    vec3 albedo;
    float metallic;
    float roughness;
};

void set_face_normal(inout hit_s hit, vec3 ray_direction, vec3 outward_normal) {
    hit.front_face = dot(ray_direction, outward_normal) < 0.0;
    hit.normal = hit.front_face ? outward_normal : -outward_normal;
}

bool hits_object(Object obj, vec3 ray_origin, vec3 ray_direction, minmax_s bounds, out hit_s hit) {
    if (obj.object_type == OBJECT_TYPE_SPHERE) {
        vec3 center = obj.data1.xyz;
        float radius = obj.data2.x;

        float t = hits_sphere(center, radius, ray_origin, ray_direction, bounds);
        if (t > 0.0) {
            hit.valid = true;
            hit.t = t;
            hit.point = ray_origin + t * ray_direction;
            hit.normal = normalize(hit.point - center);
            hit.albedo = obj.albedo.rgb;
            hit.metallic = obj.metallic_roughness.x;
            hit.roughness = obj.metallic_roughness.y;
            set_face_normal(hit, ray_direction, hit.normal);
            return true;
        }
    }

    return false;
}

bool hits_world(vec3 ray_origin, vec3 ray_direction, minmax_s bounds, out hit_s hit) {
    bool hit_anything = false;

    for (int i = 0; i < int(in_config.objects_count); i++) {
        hit_s temp_hit;
        if (hits_object(objects[i], ray_origin, ray_direction, bounds, temp_hit)) {
            hit = temp_hit;
            hit_anything = true;
            bounds.max = temp_hit.t;
        }
    }

    return hit_anything;
}

#define MAX_BOUNCES 10

vec4 trace(vec3 ray_origin, vec3 ray_direction, inout uint seed) {
    vec3 bounce_dir = ray_direction;
    vec3 bounce_origin = ray_origin;

    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);

    minmax_s bounds;
    bounds.min = 0.001;
    bounds.max = 1e20;

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        hit_s hit;
        if (!hits_world(bounce_origin, bounce_dir, bounds, hit)) {
            // Hit the sky
            color += attenuation * sky_color(bounce_dir);
            break;
        }

        attenuation *= hit.albedo;

        // Prepare for next bounce
        vec3 reflected = normalize(reflect(bounce_dir, hit.normal)) * (hit.metallic);

        vec3 scatter = hit.normal + rand_unit(seed);
        // Catch degenerate scatter direction
        if (length(scatter) < 1e-3) {
            scatter = hit.normal;
        }
        scatter *= hit.roughness;

        bounce_dir = normalize(scatter + reflected);
        bounce_origin = hit.point + 0.001 * bounce_dir; // Offset to avoid self-intersection
    }

    return vec4(color, 1.0);
}

vec2 jitter(float jitter_strength, inout uint seed) {
    return vec2(
        (rand(seed) - 0.5) * jitter_strength,
        (rand(seed) - 0.5) * jitter_strength
    );
}

vec3 ray_direction(vec2 uv, ivec2 viewport, float fov, mat4 camera_transform) {
    vec2 ndc = uv * 2.0 - 1.0; // [-1..1]
    float aspect = float(viewport.x) / float(viewport.y);
    ndc.x *= aspect;

    float scale = tan(fov * 0.5);
    vec3 dir_cam = normalize(vec3(ndc * scale, -1.0));

    vec3 camera_forward = normalize(camera_transform[2].xyz);
    vec3 camera_right = normalize(camera_transform[0].xyz);
    vec3 camera_up = normalize(camera_transform[1].xyz);

    vec3 ray_direction = normalize(
        dir_cam.x * camera_right +
        dir_cam.y * camera_up +
        dir_cam.z * camera_forward
    );

    return ray_direction;
}

void main() {
    ivec2 viewport = imageSize(output_image);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    if (pixel_coords.x >= viewport.x || pixel_coords.y >= viewport.y)
    {
        return;
    }

    vec3 ray_origin = in_config.camera_transform[3].xyz;
    vec4 color = vec4(0.0);

    // Deterministic seed used for jitter calculation
    uint jitter_seed = uint(pixel_coords.x + pixel_coords.y * viewport.x) + uint(in_runtime.time * 1000.0);
    // Seed used for tracing rays
    uint trace_seed = jitter_seed;

    for (uint s = 0u; s < in_config.samples_count; s++) {
        vec2 jitter_offset = jitter(in_config.jitter_strength, jitter_seed);
        vec2 uv = (vec2(pixel_coords) + vec2(0.5) + jitter_offset) / vec2(viewport);

        vec3 ray_direction = ray_direction(
            uv,
            viewport,
            in_config.camera_fov,
            in_config.camera_transform
        );
        color += trace(ray_origin, ray_direction, trace_seed);
    }
    color = color / float(in_config.samples_count);

    // Simple gamma correction
    color.rgb = pow(color.rgb, vec3(1.0 / 2.2));

    // If invalidate is set, we overwrite the pixel directly
    if (in_runtime.invalidate == 1u) {
        imageStore(output_image, pixel_coords, color);
    } else {
        vec4 old_color = imageLoad(output_image, pixel_coords);
        color = mix(color, old_color, in_config.temporal_accumulation);
        imageStore(output_image, pixel_coords, color);
    }
}
